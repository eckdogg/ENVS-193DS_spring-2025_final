---
title: "ENVS193DS Final"
author: Owen Eckweiler
date: 6/10/2025
editor: source
format:
  html:
    toc: true # use this to display a table of contents
execute:
  message: false # use this to make sure messages don't show up
  warning: false # use this to make sure warnings don't show up
---

# Repository Link

<https://github.com/eckdogg/ENVS-193DS_spring-2025_final.git>


# Set up

```{r}
library("tidyverse")
library("here")
library("janitor")
library("tibble")
library("DHARMa")
library("MuMIn")
library("ggeffects")
library("scales")

sst <- read_csv(here("data", "SST_update2023.csv"))
nest_boxes <- read_csv(here("data", "occdist.csv"))
nest_boxes_clean <- janitor::clean_names(nest_boxes)
```


# Problem 1. Research writing

## a. 

In part 1, they used a Pearson's r correlation test. In part 2, they used a one-way ANOVA test.

## b. 

Two additional tests that could be included are a Tukey's HSD test and an eta-squared test. Tukey's HSD will tell us what groups are significantly different from each other. In this example there are 5 groups (urban land, atmospheric deposition, fertilizer, wastewater treatment, and grasslands). An eta-squared test will give us the effect size between groups. Effect size will tell us how large the difference is between groups. 

## c.

There is a difference in average nitrogen load (kg year<sup>-1</sup>) between sources (urban land, atmospheric deposition, fertilizer, wastewater treatment, and grasslands) (p = 0.02). We found a large difference ($\eta^2$ = effect size) between sources in average nitrogen load (one-way ANOVA results). On average urban land tended to have larger nitrogen loads than atmospheric deposition (Tukey's HSD results), fertilizer (Tukey's HSD results), fertilizer (Tukey's HSD results), wastewater treatment (Tukey's HSD results), and grasslands (Tukey's HSD results).


# Problem 2. Data visualization

## a.

```{r}
sst_clean <- sst |> # cleaning data from sst data frame
  mutate(date = ymd(date), # creating date objects
         year = factor(year(date), levels = 2018:2023), # turning year variable into a factor
         month = month(date, label = TRUE, abbr = TRUE)) |> # creating a month column
  filter(!is.na(year)) |> # filtering out rows without a year value
  group_by(year, month) |> # grouping by year and month
  summarize(mean_monthly_sst = round(mean(temp, na.rm = TRUE), 1),
            .groups = "drop") # taking the mean sst for each month

sst_clean |> 
  slice_sample(n = 5) # displaying 5 random rows of data

str(sst_clean) # displaying the data structure
```

## b.

```{r}
ggplot(sst_clean, aes(x = month, y = mean_monthly_sst, group = year, color = year)) + # using sst_clean data frame and setting values
  geom_line(size = 0.8) + # line geometry
  geom_point(size = 1.5) + # point geometry
  labs( # setting axis labels
    x = "Month", # x axis label
    y = "Mean monthly sea surface temperature (Â°C)", # y axis label
    color = "Year" # coloring based on year
  ) +
  scale_color_manual( # manually setting color scale
    values = c(
      "2018" = "#deebf7", # color for 2018 (lightest blue)
      "2019" = "#c6dbef", # color for 2019
      "2020" = "#9ecae1", # color for 2020
      "2021" = "#6baed6", # color for 2021
      "2022" = "#3182bd", # color for 2022
      "2023" = "#08519c"  # color for 2023 (darkest blue)
    )
  ) +
  scale_y_continuous(limits = c(12, 20)) + # only displaying values between 12 and 20 on y axis
  theme_minimal(base_size = 14) + # setting base font size to 14 points
  theme(
    legend.position = c(0.00, 1.00),  # setting legend position
    legend.justification = c("left", "top"),  # pin legend to top-left
    plot.margin = margin(t = 10, r = 10, b = 10, l = 30), # setting plot margin
    axis.title.y = element_text(margin = margin(r = 10)), # setting margin for y axis
    panel.grid.major = element_blank(),  # removing major gridlines
    panel.grid.minor = element_blank(),  # removing minor gridlines
    panel.background = element_blank(),  # removing background
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5)  # setting border color and size
  )
```


# Problem 3. Data analysis

## a.

A 1 represents the presence of a species and a 0 represents the absence of a species. For example a 1 underneath the sp column represents the presence of a swift parrot in a nest box.

## b.

In this study, the nest boxes were built for Swift Parrot habitat restoration. However in the location where the nest boxes were built there are two other species that compete with Swift Parrots for nest boxes (Tree Martins and Common Starlings).

## c.

The two years compared in the study are 2016 and 2019, which were subsequent breeding seasons. Nest boxes were originally established in 2016 and were used again in 2019. 

## d.

| Model number | Season | Distance to Forest Edge | Model Description | 
|:------------:|:---:|:---------------:|:-------:|-----------------------------|  
| 0            |        |                          | No predictors (null model) |
| 1            |  X     |       X                 | All predictors (saturated model) | 
| 2            |  X     |                         | Season |   
| 3            |       |       X                  | Distance to Forest Edge |  

## e.

```{r}
# model 0: null model
model0 <- glm(sp ~ 1, # formula
  data = nest_boxes_clean,
  family = "binomial" # data frame
)

# model 1: saturated model
model1 <- glm(sp ~ edge_distance + season, # formula
  data = nest_boxes_clean,
  family = "binomial" # data frame
)

# model 2: season
model2 <- glm(sp ~ season, # formula
  data = nest_boxes_clean,
  family = "binomial" # data frame
)

# model 3: edge distance
model3 <- glm(sp ~ edge_distance, # formula
  data = nest_boxes_clean,
  family = "binomial" # data frame
)
```

## f.

```{r}
plot(
  simulateResiduals(model0)
)

plot(
  simulateResiduals(model1)
)

plot(
  simulateResiduals(model2)
)

plot(
  simulateResiduals(model3)
)
```

## g.

```{r}
AICc(model0,
     model1, # best model: All predictors (saturated model)
     model2,
     model3) |>
  # arranging output in descending order of AIC
  arrange(AICc)
```

## h.

```{r}
nest_boxes_clean$season <- as.factor(nest_boxes_clean$season)

mod_preds <- ggpredict(model1, terms = c("edge_distance [all]", "season"))

ggplot() +
  geom_point(data = nest_boxes_clean,
             aes(x = edge_distance,
                 y = sp,  
                 color = season),
             size = 3,
             alpha = 0.4) +
  geom_ribbon(data = mod_preds,
              aes(x = x,
                  ymin = conf.low,
                  ymax = conf.high,
                  fill = group),
              alpha = 0.4) +
  geom_line(data = mod_preds,
            aes(x = x,
                y = predicted,
                color = group),
            linewidth = 1) +  
  scale_y_continuous("Probability of box occupancy",
                   limits = c(0, 1),
                   breaks = seq(0, 1, by = 0.2),
                   labels = label_percent(accuracy = 1)) +
  scale_color_manual(name = "Season",
                   values = c("2016" = "darkblue", "2019" = "lightgreen")) +
  scale_fill_manual(name = "Season",
                   values = c("2016" = "darkblue", "2019" = "lightgreen")) +
  labs(x = "Distance from the forest edge (m)",
       title = "Swift Parrot") +
  theme_minimal(base_size = 14) +
  theme_minimal(base_size = 14) +
theme(
  panel.grid = element_blank())

```

## i.

**Figure 1. Swift parrots are more likely to be found near forest edges.** Data from 'occdist' csv file (Stojanovic, Dejan et al. (2021)).
Points represent observations of swift parrot presence at individual nest boxes at various distances from forest edges (m). Points at 100% on the y axis represent swift parrot presence and points at 0% represent a lack of presence. Lines represent the predicted probability of swift parrot presence based on distance from forest edge. Colors represent seasons (blue: 2016, green: 2019).

## j.

```{r}
nest_boxes_clean$season <- as.factor(nest_boxes_clean$season)
ggpredict(model1, terms = c("edge_distance [0]", "season"))
```

## k.

